### ERC20PermitPermissionedMint.sol
1. In the contract `ERC20PermitPermissionedMint`, line 32 sets the owner to `_creator_address`. Although owner cannot be zero address, if the input is incorrect, the contract will have to be redeployed since the ownership cannot be changed unless the deployer happens to controll the mistaken address. Consider using `msg.sender` instead of `_creator_address` and changing the ownership with the function `Owned.nominateNewOwner()`.
2. In the contract `ERC20PermitPermissionedMint`, line 34 sets the `timelock_address`. However the constructor does not emit the event `TimelockChanged`. Consider emitting the event `TimelockChanged` to make it easier for off chain services to filter for relevant events.
3. In the contract `ERC20PermitPermissionedMint`, the function `minter_burn_from()` on line 53 has the modifier `onlyMinters`, restricting only addresses with the minter role to call this function. However, it calls the `burnFrom()` in the parent contract, which is a public function without access control, allowing anyone to burn their token balance or allowance. If the intention of the `minter_burn_from()` was to restrict the users who could burn, consider overriding the `burnFrom()` function and adding the modifier `onlyMinters` to it.
4. In the contract `ERC20PermitPermissionedMint`, the function `minter_burn_from()` on line 53 has the modifier `onlyMinters`, restricting only addresses with the minter role to call this function. The minter is assumed to be the contract `frxETHMinter`, however, this contract does not include any call to `minter_burn_from()`, making this function uncallable with the default code. As mentioned in number 3, burning functionality is still available due to the public `burnFrom()` function. Check if burning functionality should be included in `frxETHMinter` contract and if not, to either remove `minter_burn_from()` and use `burnFrom()` instead or use a regular ERC20 contract instead of a burnable ERC20 contract.
5. In the contract `ERC20PermitPermissionedMint`, several events are unindexed. Consider indexing the events to make it easier for off chain services to filter for relevant events.
   - `MinterAdded`
   - `MinterRemoved`
   - `TimelockChanged`
6. In the contract `ERC20PermitPermissionedMint`, the event `TokenMinterBurned` emits a `to` address. However, this is misleading since tokens are not burned "to" the address, instead they are burned "by" the address. Consider changing `to` to something like "by" or "burner" which better conveys the intent.
7. In the contract `ERC20PermitPermissionedMint`, line 86 "removes" the address stored at the index by setting it to the zero address. However, the array will still have iterate the zeroed address since they exist in the array. In a worse case scenario, if the array is long enough, it could result in not being able to revoke minter role for addresses pass a certain index due to an out-of-gas error. Consider changing line 86 to the following:
```
minters_array[i] = minters_array[minters_array.length - 1];
minters_array.pop();
```

### frxETHMinter.sol
1. In the contract `frxETHMinter`, the function `submitAndGive()` on line 109 can be called with recipient set to the minting contract. Although users should call `submitAndDeposit()` instead of `submitAndGive()` to immediately convert frxETH to sfrxETH, it is still recommended to include a `require(recipient != address(this))` to prevent such a mistake from happening.
2. In the contract `frxETHMinter`, the function `depositEther()` will perform n/32 number of loops where n is the ether deposited to the contract. Given a large enough balance, it is theoretically possible to cause the function to revert due to an out-of-gas error. Although it can be remediated by calling the `recoverEther` function to transfer some ether out of the contract, it may be worth having a limit on the number of deposits in a single transaction or have a separate function for creating one validator at a time. 
3. In the contract `frxETHMinter`, the function `recoverERC20()` on line 199, takes in any `tokenAddress` as an input for the ERC20 token to transfer out. Dependening on the use case of this function, if owner is tricked into calling this function with a malicious `tokenAddress`, the call to the malicious contract could be delegated to `frxETH` contract to mint an arbitrary amount of token. Carefully check the input address or consider limiting recoveries to a predetermined list of tokens.
4. In the contract `frxETHMinster`,  the event `EmergencyERC20Recovered` on line 206 is not indexed. Consider indexing the `address` parameter to make it easier for off-chain services monitoring the events to search and filter for relevant information.

### sfrxETH.sol
1. In the contract `sfrxETH.sol`,the function `depositWithSignature` determines the `amount` based on the input of `approveMax` on line 68. The same operation is performed for the function `mintWithSignature` on line 84. However, for the function `mintWithSignature`, if `approveMax` is false, it uses `previewMint(shares)`, whereas the function `depositWithSignature` uses the input `assets`. Check if `previewDeposit()` should be used instead.